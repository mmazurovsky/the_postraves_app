// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'follow_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$FollowStateTearOff {
  const _$FollowStateTearOff();

  UnclearFollowState unclear() {
    return const UnclearFollowState();
  }

  FollowedFollowState followed() {
    return const FollowedFollowState();
  }

  UnfollowedFollowState unfollowed() {
    return const UnfollowedFollowState();
  }
}

/// @nodoc
const $FollowState = _$FollowStateTearOff();

/// @nodoc
mixin _$FollowState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unclear,
    required TResult Function() followed,
    required TResult Function() unfollowed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unclear,
    TResult Function()? followed,
    TResult Function()? unfollowed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnclearFollowState value) unclear,
    required TResult Function(FollowedFollowState value) followed,
    required TResult Function(UnfollowedFollowState value) unfollowed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnclearFollowState value)? unclear,
    TResult Function(FollowedFollowState value)? followed,
    TResult Function(UnfollowedFollowState value)? unfollowed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FollowStateCopyWith<$Res> {
  factory $FollowStateCopyWith(
          FollowState value, $Res Function(FollowState) then) =
      _$FollowStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$FollowStateCopyWithImpl<$Res> implements $FollowStateCopyWith<$Res> {
  _$FollowStateCopyWithImpl(this._value, this._then);

  final FollowState _value;
  // ignore: unused_field
  final $Res Function(FollowState) _then;
}

/// @nodoc
abstract class $UnclearFollowStateCopyWith<$Res> {
  factory $UnclearFollowStateCopyWith(
          UnclearFollowState value, $Res Function(UnclearFollowState) then) =
      _$UnclearFollowStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnclearFollowStateCopyWithImpl<$Res>
    extends _$FollowStateCopyWithImpl<$Res>
    implements $UnclearFollowStateCopyWith<$Res> {
  _$UnclearFollowStateCopyWithImpl(
      UnclearFollowState _value, $Res Function(UnclearFollowState) _then)
      : super(_value, (v) => _then(v as UnclearFollowState));

  @override
  UnclearFollowState get _value => super._value as UnclearFollowState;
}

/// @nodoc

class _$UnclearFollowState implements UnclearFollowState {
  const _$UnclearFollowState();

  @override
  String toString() {
    return 'FollowState.unclear()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnclearFollowState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unclear,
    required TResult Function() followed,
    required TResult Function() unfollowed,
  }) {
    return unclear();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unclear,
    TResult Function()? followed,
    TResult Function()? unfollowed,
    required TResult orElse(),
  }) {
    if (unclear != null) {
      return unclear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnclearFollowState value) unclear,
    required TResult Function(FollowedFollowState value) followed,
    required TResult Function(UnfollowedFollowState value) unfollowed,
  }) {
    return unclear(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnclearFollowState value)? unclear,
    TResult Function(FollowedFollowState value)? followed,
    TResult Function(UnfollowedFollowState value)? unfollowed,
    required TResult orElse(),
  }) {
    if (unclear != null) {
      return unclear(this);
    }
    return orElse();
  }
}

abstract class UnclearFollowState implements FollowState {
  const factory UnclearFollowState() = _$UnclearFollowState;
}

/// @nodoc
abstract class $FollowedFollowStateCopyWith<$Res> {
  factory $FollowedFollowStateCopyWith(
          FollowedFollowState value, $Res Function(FollowedFollowState) then) =
      _$FollowedFollowStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$FollowedFollowStateCopyWithImpl<$Res>
    extends _$FollowStateCopyWithImpl<$Res>
    implements $FollowedFollowStateCopyWith<$Res> {
  _$FollowedFollowStateCopyWithImpl(
      FollowedFollowState _value, $Res Function(FollowedFollowState) _then)
      : super(_value, (v) => _then(v as FollowedFollowState));

  @override
  FollowedFollowState get _value => super._value as FollowedFollowState;
}

/// @nodoc

class _$FollowedFollowState implements FollowedFollowState {
  const _$FollowedFollowState();

  @override
  String toString() {
    return 'FollowState.followed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is FollowedFollowState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unclear,
    required TResult Function() followed,
    required TResult Function() unfollowed,
  }) {
    return followed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unclear,
    TResult Function()? followed,
    TResult Function()? unfollowed,
    required TResult orElse(),
  }) {
    if (followed != null) {
      return followed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnclearFollowState value) unclear,
    required TResult Function(FollowedFollowState value) followed,
    required TResult Function(UnfollowedFollowState value) unfollowed,
  }) {
    return followed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnclearFollowState value)? unclear,
    TResult Function(FollowedFollowState value)? followed,
    TResult Function(UnfollowedFollowState value)? unfollowed,
    required TResult orElse(),
  }) {
    if (followed != null) {
      return followed(this);
    }
    return orElse();
  }
}

abstract class FollowedFollowState implements FollowState {
  const factory FollowedFollowState() = _$FollowedFollowState;
}

/// @nodoc
abstract class $UnfollowedFollowStateCopyWith<$Res> {
  factory $UnfollowedFollowStateCopyWith(UnfollowedFollowState value,
          $Res Function(UnfollowedFollowState) then) =
      _$UnfollowedFollowStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UnfollowedFollowStateCopyWithImpl<$Res>
    extends _$FollowStateCopyWithImpl<$Res>
    implements $UnfollowedFollowStateCopyWith<$Res> {
  _$UnfollowedFollowStateCopyWithImpl(
      UnfollowedFollowState _value, $Res Function(UnfollowedFollowState) _then)
      : super(_value, (v) => _then(v as UnfollowedFollowState));

  @override
  UnfollowedFollowState get _value => super._value as UnfollowedFollowState;
}

/// @nodoc

class _$UnfollowedFollowState implements UnfollowedFollowState {
  const _$UnfollowedFollowState();

  @override
  String toString() {
    return 'FollowState.unfollowed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is UnfollowedFollowState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unclear,
    required TResult Function() followed,
    required TResult Function() unfollowed,
  }) {
    return unfollowed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unclear,
    TResult Function()? followed,
    TResult Function()? unfollowed,
    required TResult orElse(),
  }) {
    if (unfollowed != null) {
      return unfollowed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UnclearFollowState value) unclear,
    required TResult Function(FollowedFollowState value) followed,
    required TResult Function(UnfollowedFollowState value) unfollowed,
  }) {
    return unfollowed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UnclearFollowState value)? unclear,
    TResult Function(FollowedFollowState value)? followed,
    TResult Function(UnfollowedFollowState value)? unfollowed,
    required TResult orElse(),
  }) {
    if (unfollowed != null) {
      return unfollowed(this);
    }
    return orElse();
  }
}

abstract class UnfollowedFollowState implements FollowState {
  const factory UnfollowedFollowState() = _$UnfollowedFollowState;
}
